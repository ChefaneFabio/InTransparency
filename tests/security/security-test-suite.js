/**
 * Comprehensive Security Testing Suite for InTransparency Platform
 * Tests all security implementations and vulnerabilities
 */

const request = require('supertest')
const crypto = require('crypto')

class SecurityTestSuite {
  constructor(app, baseURL = 'http://localhost:3001') {
    this.app = app
    this.baseURL = baseURL
    this.testResults = []
    this.vulnerabilities = []
  }

  // Run all security tests
  async runAllTests() {
    console.log('🔒 Starting Comprehensive Security Test Suite')
    console.log('=' .repeat(50))

    const testCategories = [
      { name: 'Authentication Security', tests: this.runAuthenticationTests.bind(this) },
      { name: 'Input Validation', tests: this.runInputValidationTests.bind(this) },
      { name: 'Authorization Controls', tests: this.runAuthorizationTests.bind(this) },
      { name: 'Rate Limiting', tests: this.runRateLimitingTests.bind(this) },
      { name: 'Security Headers', tests: this.runSecurityHeadersTests.bind(this) },
      { name: 'CORS Configuration', tests: this.runCORSTests.bind(this) },
      { name: 'Session Management', tests: this.runSessionTests.bind(this) },
      { name: 'Password Security', tests: this.runPasswordTests.bind(this) },
      { name: 'SQL Injection', tests: this.runSQLInjectionTests.bind(this) },
      { name: 'XSS Protection', tests: this.runXSSTests.bind(this) },
      { name: 'File Upload Security', tests: this.runFileUploadTests.bind(this) },
      { name: 'Error Handling', tests: this.runErrorHandlingTests.bind(this) }\n    ]\n\n    for (const category of testCategories) {\n      console.log(`\\n🧪 Testing: ${category.name}`)\n      console.log('-'.repeat(30))\n      await category.tests()\n    }\n\n    this.generateReport()\n  }\n\n  // Authentication Security Tests\n  async runAuthenticationTests() {\n    await this.test('JWT Secret Validation', async () => {\n      // Test that endpoints reject requests without proper JWT\n      const response = await request(this.app)\n        .get('/api/users/me')\n        .expect(401)\n\n      return {\n        passed: response.status === 401,\n        details: 'Properly rejects unauthenticated requests'\n      }\n    })\n\n    await this.test('Invalid JWT Handling', async () => {\n      const response = await request(this.app)\n        .get('/api/users/me')\n        .set('Authorization', 'Bearer invalid-token')\n        .expect(401)\n\n      return {\n        passed: response.status === 401,\n        details: 'Properly rejects invalid JWT tokens'\n      }\n    })\n\n    await this.test('Token Expiry Handling', async () => {\n      // Create an expired token for testing\n      const expiredToken = this.createExpiredJWT()\n      const response = await request(this.app)\n        .get('/api/users/me')\n        .set('Authorization', `Bearer ${expiredToken}`)\n        .expect(401)\n\n      return {\n        passed: response.status === 401,\n        details: 'Properly rejects expired tokens'\n      }\n    })\n\n    await this.test('Login Rate Limiting', async () => {\n      // Attempt multiple failed logins\n      let rateLimited = false\n      for (let i = 0; i < 10; i++) {\n        const response = await request(this.app)\n          .post('/api/auth/login')\n          .send({ email: 'test@example.com', password: 'wrongpassword' })\n\n        if (response.status === 429) {\n          rateLimited = true\n          break\n        }\n      }\n\n      return {\n        passed: rateLimited,\n        details: rateLimited ? 'Login rate limiting active' : 'No rate limiting detected'\n      }\n    })\n  }\n\n  // Input Validation Tests\n  async runInputValidationTests() {\n    const maliciousInputs = [\n      { name: 'SQL Injection', payload: \"'; DROP TABLE users; --\" },\n      { name: 'XSS Script', payload: '<script>alert(\"XSS\")</script>' },\n      { name: 'Path Traversal', payload: '../../../etc/passwd' },\n      { name: 'NoSQL Injection', payload: { '$ne': null } },\n      { name: 'Command Injection', payload: '; cat /etc/passwd' },\n      { name: 'XXE Payload', payload: '<?xml version=\"1.0\"?><!DOCTYPE data [<!ENTITY file SYSTEM \"file:///etc/passwd\">]><data>&file;</data>' }\n    ]\n\n    for (const input of maliciousInputs) {\n      await this.test(`${input.name} Protection`, async () => {\n        const response = await request(this.app)\n          .post('/api/auth/login')\n          .send({ email: input.payload, password: input.payload })\n\n        const blocked = response.status === 400 || response.body.error === 'Invalid characters detected in input'\n\n        return {\n          passed: blocked,\n          details: blocked ? `${input.name} properly blocked` : `${input.name} not blocked`\n        }\n      })\n    }\n\n    await this.test('Large Payload Protection', async () => {\n      const largePayload = 'A'.repeat(50 * 1024 * 1024) // 50MB\n      const response = await request(this.app)\n        .post('/api/auth/login')\n        .send({ email: largePayload, password: 'test' })\n\n      return {\n        passed: response.status === 413 || response.status === 400,\n        details: 'Large payload properly rejected'\n      }\n    })\n  }\n\n  // Authorization Tests\n  async runAuthorizationTests() {\n    await this.test('Admin Route Protection', async () => {\n      const userToken = this.createUserToken('user')\n      const response = await request(this.app)\n        .get('/api/admin/users')\n        .set('Authorization', `Bearer ${userToken}`)\n\n      return {\n        passed: response.status === 403 || response.status === 404,\n        details: 'Non-admin users cannot access admin routes'\n      }\n    })\n\n    await this.test('Resource Ownership Check', async () => {\n      const userToken = this.createUserToken('user', 'user1')\n      const response = await request(this.app)\n        .get('/api/users/user2/profile')\n        .set('Authorization', `Bearer ${userToken}`)\n\n      return {\n        passed: response.status === 403 || response.status === 404,\n        details: 'Users cannot access other users resources'\n      }\n    })\n  }\n\n  // Rate Limiting Tests\n  async runRateLimitingTests() {\n    await this.test('API Rate Limiting', async () => {\n      let rateLimited = false\n      const userToken = this.createUserToken('user')\n\n      // Make rapid requests\n      for (let i = 0; i < 150; i++) {\n        const response = await request(this.app)\n          .get('/api/health')\n          .set('Authorization', `Bearer ${userToken}`)\n\n        if (response.status === 429) {\n          rateLimited = true\n          break\n        }\n      }\n\n      return {\n        passed: rateLimited,\n        details: rateLimited ? 'API rate limiting active' : 'No API rate limiting detected'\n      }\n    })\n\n    await this.test('Rate Limit Headers', async () => {\n      const response = await request(this.app)\n        .get('/api/health')\n\n      const hasRateLimitHeaders = response.headers['x-ratelimit-limit'] &&\n                                 response.headers['x-ratelimit-remaining']\n\n      return {\n        passed: hasRateLimitHeaders,\n        details: hasRateLimitHeaders ? 'Rate limit headers present' : 'Rate limit headers missing'\n      }\n    })\n  }\n\n  // Security Headers Tests\n  async runSecurityHeadersTests() {\n    const requiredHeaders = [\n      'x-frame-options',\n      'x-content-type-options',\n      'x-xss-protection',\n      'referrer-policy',\n      'content-security-policy'\n    ]\n\n    for (const header of requiredHeaders) {\n      await this.test(`${header.toUpperCase()} Header`, async () => {\n        const response = await request(this.app).get('/api/health')\n        const hasHeader = response.headers[header] !== undefined\n\n        return {\n          passed: hasHeader,\n          details: hasHeader ? `${header} header present` : `${header} header missing`\n        }\n      })\n    }\n\n    await this.test('Server Header Removal', async () => {\n      const response = await request(this.app).get('/api/health')\n      const serverHeaderHidden = !response.headers['server'] && !response.headers['x-powered-by']\n\n      return {\n        passed: serverHeaderHidden,\n        details: serverHeaderHidden ? 'Server identification headers removed' : 'Server headers exposed'\n      }\n    })\n  }\n\n  // CORS Tests\n  async runCORSTests() {\n    await this.test('CORS Origin Validation', async () => {\n      const response = await request(this.app)\n        .options('/api/health')\n        .set('Origin', 'https://malicious-site.com')\n\n      const corsBlocked = !response.headers['access-control-allow-origin'] ||\n                         response.headers['access-control-allow-origin'] !== 'https://malicious-site.com'\n\n      return {\n        passed: corsBlocked,\n        details: corsBlocked ? 'Malicious origin blocked' : 'Malicious origin allowed'\n      }\n    })\n\n    await this.test('CORS Credentials Handling', async () => {\n      const response = await request(this.app)\n        .options('/api/health')\n        .set('Origin', 'http://localhost:3000')\n\n      const credentialsHandled = response.headers['access-control-allow-credentials'] === 'true'\n\n      return {\n        passed: credentialsHandled,\n        details: credentialsHandled ? 'Credentials properly configured' : 'Credentials configuration missing'\n      }\n    })\n  }\n\n  // Session Management Tests\n  async runSessionTests() {\n    await this.test('Session Cookie Security', async () => {\n      const response = await request(this.app)\n        .post('/api/auth/login')\n        .send({ email: 'test@example.com', password: 'validpassword' })\n\n      const setCookieHeader = response.headers['set-cookie']\n      let secure = false\n      let httpOnly = false\n      let sameSite = false\n\n      if (setCookieHeader) {\n        const cookieString = setCookieHeader.join('; ')\n        secure = cookieString.includes('Secure')\n        httpOnly = cookieString.includes('HttpOnly')\n        sameSite = cookieString.includes('SameSite')\n      }\n\n      return {\n        passed: httpOnly && sameSite,\n        details: `HttpOnly: ${httpOnly}, Secure: ${secure}, SameSite: ${sameSite}`\n      }\n    })\n  }\n\n  // Password Security Tests\n  async runPasswordTests() {\n    await this.test('Password Strength Validation', async () => {\n      const weakPasswords = ['123456', 'password', 'qwerty', 'abc123']\n      let allRejected = true\n\n      for (const password of weakPasswords) {\n        const response = await request(this.app)\n          .post('/api/auth/register')\n          .send({\n            email: 'test@example.com',\n            password,\n            firstName: 'Test',\n            lastName: 'User',\n            role: 'student'\n          })\n\n        if (response.status === 201) {\n          allRejected = false\n          break\n        }\n      }\n\n      return {\n        passed: allRejected,\n        details: allRejected ? 'Weak passwords rejected' : 'Weak passwords accepted'\n      }\n    })\n\n    await this.test('Password Reset Rate Limiting', async () => {\n      let rateLimited = false\n\n      for (let i = 0; i < 10; i++) {\n        const response = await request(this.app)\n          .post('/api/auth/forgot-password')\n          .send({ email: 'test@example.com' })\n\n        if (response.status === 429) {\n          rateLimited = true\n          break\n        }\n      }\n\n      return {\n        passed: rateLimited,\n        details: rateLimited ? 'Password reset rate limited' : 'No password reset rate limiting'\n      }\n    })\n  }\n\n  // SQL Injection Tests\n  async runSQLInjectionTests() {\n    const sqlPayloads = [\n      \"' OR '1'='1\",\n      \"'; DROP TABLE users; --\",\n      \"' UNION SELECT * FROM users --\",\n      \"1' OR '1'='1' /*\",\n      \"admin'--\",\n      \"' OR 1=1#\"\n    ]\n\n    for (const payload of sqlPayloads) {\n      await this.test(`SQL Injection: ${payload}`, async () => {\n        const response = await request(this.app)\n          .post('/api/auth/login')\n          .send({ email: payload, password: 'test' })\n\n        const blocked = response.status === 400 && \n                       response.body.error === 'Invalid characters detected in input'\n\n        return {\n          passed: blocked,\n          details: blocked ? 'SQL injection blocked' : 'SQL injection not blocked'\n        }\n      })\n    }\n  }\n\n  // XSS Protection Tests\n  async runXSSTests() {\n    const xssPayloads = [\n      '<script>alert(\"XSS\")</script>',\n      '<img src=x onerror=alert(\"XSS\")>',\n      'javascript:alert(\"XSS\")',\n      '<svg onload=alert(\"XSS\")>',\n      '\"><script>alert(\"XSS\")</script>',\n      \"'><script>alert('XSS')</script>\"\n    ]\n\n    for (const payload of xssPayloads) {\n      await this.test(`XSS Protection: ${payload.substring(0, 20)}...`, async () => {\n        const response = await request(this.app)\n          .post('/api/auth/register')\n          .send({\n            email: 'test@example.com',\n            password: 'ValidPass123!',\n            firstName: payload,\n            lastName: 'User',\n            role: 'student'\n          })\n\n        // Check if XSS payload was sanitized in response\n        const responseString = JSON.stringify(response.body)\n        const containsPayload = responseString.includes(payload)\n\n        return {\n          passed: !containsPayload,\n          details: containsPayload ? 'XSS payload reflected' : 'XSS payload sanitized'\n        }\n      })\n    }\n  }\n\n  // File Upload Security Tests\n  async runFileUploadTests() {\n    await this.test('Malicious File Upload Prevention', async () => {\n      // Test uploading a PHP file\n      const response = await request(this.app)\n        .post('/api/files/upload')\n        .attach('file', Buffer.from('<?php system($_GET[\"cmd\"]); ?>'), 'shell.php')\n\n      return {\n        passed: response.status === 400 || response.status === 415,\n        details: 'Malicious file upload blocked'\n      }\n    })\n\n    await this.test('File Size Limit', async () => {\n      const largeFile = Buffer.alloc(50 * 1024 * 1024) // 50MB\n      const response = await request(this.app)\n        .post('/api/files/upload')\n        .attach('file', largeFile, 'large.txt')\n\n      return {\n        passed: response.status === 413,\n        details: 'Large file upload rejected'\n      }\n    })\n  }\n\n  // Error Handling Tests\n  async runErrorHandlingTests() {\n    await this.test('Error Information Disclosure', async () => {\n      const response = await request(this.app)\n        .get('/api/nonexistent-endpoint')\n\n      const errorResponse = JSON.stringify(response.body)\n      const containsStack = errorResponse.includes('stack') || \n                           errorResponse.includes('at ') ||\n                           errorResponse.includes('.js:')\n\n      return {\n        passed: !containsStack,\n        details: containsStack ? 'Stack trace leaked in error' : 'Error information properly sanitized'\n      }\n    })\n\n    await this.test('Database Error Handling', async () => {\n      // Try to cause a database error\n      const response = await request(this.app)\n        .get('/api/users/invalid-id-format')\n\n      const errorResponse = JSON.stringify(response.body)\n      const containsDBInfo = errorResponse.toLowerCase().includes('sql') ||\n                            errorResponse.toLowerCase().includes('database') ||\n                            errorResponse.toLowerCase().includes('postgres')\n\n      return {\n        passed: !containsDBInfo,\n        details: containsDBInfo ? 'Database information leaked' : 'Database errors properly handled'\n      }\n    })\n  }\n\n  // Helper Methods\n  async test(name, testFunction) {\n    try {\n      const result = await testFunction()\n      this.testResults.push({\n        name,\n        passed: result.passed,\n        details: result.details || '',\n        category: this.currentCategory\n      })\n\n      const status = result.passed ? '✅' : '❌'\n      console.log(`  ${status} ${name}: ${result.details}`)\n\n      if (!result.passed) {\n        this.vulnerabilities.push({\n          test: name,\n          severity: this.getSeverity(name),\n          details: result.details\n        })\n      }\n    } catch (error) {\n      console.log(`  ❌ ${name}: Test failed - ${error.message}`)\n      this.testResults.push({\n        name,\n        passed: false,\n        details: `Test error: ${error.message}`,\n        category: this.currentCategory\n      })\n    }\n  }\n\n  createExpiredJWT() {\n    // Create a JWT token that's already expired\n    const jwt = require('jsonwebtoken')\n    return jwt.sign(\n      { userId: 'test', exp: Math.floor(Date.now() / 1000) - 3600 },\n      'test-secret'\n    )\n  }\n\n  createUserToken(role = 'user', userId = 'test-user') {\n    const jwt = require('jsonwebtoken')\n    return jwt.sign(\n      { userId, role },\n      'test-secret',\n      { expiresIn: '1h' }\n    )\n  }\n\n  getSeverity(testName) {\n    if (testName.includes('SQL Injection') || testName.includes('XSS')) {\n      return 'Critical'\n    }\n    if (testName.includes('Authentication') || testName.includes('Authorization')) {\n      return 'High'\n    }\n    if (testName.includes('Rate Limiting') || testName.includes('Headers')) {\n      return 'Medium'\n    }\n    return 'Low'\n  }\n\n  generateReport() {\n    console.log('\\n' + '='.repeat(50))\n    console.log('🔒 SECURITY TEST REPORT')\n    console.log('='.repeat(50))\n\n    const totalTests = this.testResults.length\n    const passedTests = this.testResults.filter(t => t.passed).length\n    const failedTests = totalTests - passedTests\n\n    console.log(`\\n📊 Summary:`)\n    console.log(`  Total Tests: ${totalTests}`)\n    console.log(`  Passed: ${passedTests} ✅`)\n    console.log(`  Failed: ${failedTests} ❌`)\n    console.log(`  Success Rate: ${((passedTests / totalTests) * 100).toFixed(1)}%`)\n\n    if (this.vulnerabilities.length > 0) {\n      console.log(`\\n🚨 Vulnerabilities Found:`)\n      this.vulnerabilities.forEach((vuln, index) => {\n        console.log(`  ${index + 1}. [${vuln.severity}] ${vuln.test}`)\n        console.log(`     ${vuln.details}`)\n      })\n    } else {\n      console.log(`\\n🎉 No vulnerabilities detected!`)\n    }\n\n    console.log('\\n' + '='.repeat(50))\n  }\n}\n\nmodule.exports = SecurityTestSuite"